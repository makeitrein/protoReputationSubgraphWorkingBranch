type TransactionMetadata @entity {
  id: ID! # The TxHash toHex()
  txValue: BigInt!
  timestamp: BigInt!
  blockNumber: BigInt!
  txTo: Bytes
  txFrom: Bytes!
  txGas: BigInt!
}

type InMemoryIncrementStore @entity {
  id: ID! # Always 1 =  store this const in the mapping and always just retrieve it - then incrementValue++ when new even
  incrementValue: BigInt!
}

type MetricParam @entity {
  id: ID!

  paramName1: String
  paramValue1: String
  paramType1: String

  paramName2: String
  paramValue2: String
  paramType2: String

  paramName3: String
  paramValue3: String
  paramType3: String

  paramName4: String
  paramValue4: String
  paramType4: String

  paramName5: String
  paramValue5: String
  paramType5: String

  paramName6: String
  paramValue6: String
  paramType6: String

  paramName7: String
  paramValue7: String
  paramType7: String

  paramName8: String
  paramValue8: String
  paramType8: String

  paramName9: String
  paramValue9: String
  paramType9: String

  paramName10: String
  paramValue10: String
  paramType10: String

  paramName11: String
  paramValue11: String
  paramType11: String

  paramName12: String
  paramValue12: String
  paramType12: String

  paramName13: String
  paramValue13: String
  paramType13: String
}

type BadgeMetricLookup @entity {
  id: ID! #Combination of BaseMetric ID + BaseID
  badge: BadgeType! #Combination of
  baseMetric: BaseMetric!
}

type UserBadge @entity {
  id: ID! #BadgeTypeID + UserAddress
  badge: BadgeType! #Combination of
  account: String!
  #baseMetric: BaseMetric!
}

"""
BaseMetrics belong to a single SmartContract (Should we rename BaseMetrics to EventLog for clarity?)
"""
type BaseMetric @entity {
  id: ID!
  type: EventType!
  transactionMetadata: TransactionMetadata!
  params: MetricParam
}

"""
EventType has derived BaseMetric, eventCounter, and SmartContract
"""
type EventType @entity {
  id: ID! #ToHex of EventName
  eventCounter: BigInt!
  baseMetrics: [BaseMetric!] @derivedFrom(field: "type")
  smartContract: SmartContract
}

"""
Source of Reputation
"""
type ReputationSource @entity {
  "Name of the reputation source"
  id: ID!
  "Description of the subgraph (Optional)"
  description: String
  "Smart contracts that are part of this reputation source"
  smartContracts: [SmartContract!] @derivedFrom(field: "reputationSource")
}

"""
Smart Contracts indexed by this subgraph, belongs to a single ReputationSource
"""
type SmartContract @entity {
  "Address of smart contract + ChainID"
  id: ID!
  address: String!
  startBlock: BigInt!
  chainID: BigInt!
  reputationSource: ReputationSource!
  eventTypes: [EventType!] @derivedFrom(field: "smartContract")
}

"""
New Schema Types we are going to work with
"""

type UserProgress @entity {
  id: ID! #id is user address + BadgePathway ID
  address: String!
  badgePathway: BadgePathway!
  value: BigInt! #This should be counter or accumulator value
  #baseMetric: [BaseMetric!] #The array of BaseMetric ids that have been used so far to track progress
}

type BadgePathway @entity {
  id: ID! # passed in from front end
  badges: [BadgeType!] #What badges exist within this path (nodes on the skilltree)
  # This could be an ENUM, transaction metadata or metric param
  comparisonObject: String #object key within the base metric we are referencing ie: baseMetric['txMetadata']
  comparisonLinkage: String #What linkage is used in the comparison
  # This could be an ENUM, transaction metadata or metric param
  winnerObject: String! #object key within the base metric we are referencing the winner from ie: baseMetric['txMetadata']
  winnerLinkage: String! #What linkage represents the winner of the badge.
}

type BadgeType @entity {
  id: ID! #badge type is badgePathway id + level
  name: String! #The Badge name
  ipfs: String! #The badge image
  soul: BigInt! #soulscore of badge
  pathway: BadgePathway! #pathway this badge is a part of
}