type TransactionMetadata @entity {
  id: ID! # The TxHash toHex()
  txValue: BigInt!
  timestamp: BigInt!
  blockNumber: BigInt!
  txTo: Bytes
  txFrom: Bytes!
  txGas: BigInt!
}

type InMemoryIncrementStore @entity {
  id: ID! # Always 1 =  store this const in the mapping and always just retrieve it - then incrementValue++ when new even
  incrementValue: BigInt!
}

type MetricParam @entity {
  id: ID!

  paramName1: String
  paramValue1: String
  paramType1: String

  paramName2: String
  paramValue2: String
  paramType2: String

  paramName3: String
  paramValue3: String
  paramType3: String

  paramName4: String
  paramValue4: String
  paramType4: String

  paramName5: String
  paramValue5: String
  paramType5: String

  paramName6: String
  paramValue6: String
  paramType6: String
}

type BadgeType @entity {
  id: ID!
  name: String! #The Badge
  ipfs: String! #The
  soul: BigInt!
  linkingParam: String! # This is what ties a baseMetric to a user
  baseMetric: [BadgeMetricLookup!] #The base
}

type BadgeMetricLookup @entity {
  id: ID! #Combination of BaseMetric ID + BaseID
  badge: BadgeType! #Combination of
  baseMetric: BaseMetric!
}

type UserBadge @entity {
  id: ID! #BadgeTypeID + UserAddress
  badge: BadgeType! #Combination of
  account: Bytes!
  vanityValue: Bytes! # HOW MUCH THEY HAVE CURATED IN TOTALITY
  vanityName: Bytes! #
}

"""
BaseMetrics belong to a single SmartContract (Should we rename BaseMetrics to EventLog for clarity?)
"""
type BaseMetric @entity {
  id: ID!
  type: EventType!
  transactionMetadata: TransactionMetadata!
  params: MetricParam
}

"""
EventType has derived BaseMetric, eventCounter, and SmartContract
"""
type EventType @entity {
  id: ID! #ToHex of EventName
  eventCounter: BigInt!
  baseMetrics: [BaseMetric!] @derivedFrom(field: "type")
  smartContract: SmartContract
}

enum ReputationSourceType {
  DAO
  PROTOCOL
}
"""
Source of Reputation
"""
type ReputationSource @entity {
  "Name of the subgraph"
  id: ID!
  "Description of the subgraph (Optional)"
  description: String
  "Type of reputation source  (Optional)"
  type: ReputationSourceType
}

"""
Smart Contracts indexed by this subgraph, belongs to a single ReputationSource
"""
type SmartContract @entity {
  "Address of smart contract"
  id: ID!
  startBlock: BigInt!
  network: String!
  chain: String!
  reputationSource: ReputationSource!
}
